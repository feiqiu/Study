
---
Python基础：
Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素
len()函数:获得list元素的个数
用索引来访问list中每一个位置的元素，索引从0开始// classmates[0]
可以用-1做索引，直接获取最后一个元素,并以此类推//classmates[-1] classmates[-2]  ....
append():往list中追加元素到末尾//classmates.append('Adam')
insert():把元素插入到指定的位置，比如索引号为1的位置// classmates.insert(1, 'Jack')
pop():删除list末尾的元素,删除指定位置的元素，用pop(i)方法，其中i是索引位置
要把某个元素替换成别的元素，可以直接赋值给对应的索引位置
list里面的元素的数据类型也可以不同// L = ['Apple', 123, True]
list元素也可以是另一个list //list元素也可以是另一个list  //也就是多维数组,///可以拆开写
如果一个list中一个元素也没有，就是一个空的list，它的长度为0 //L = []
jdy:list中括号[]
====================================
tuple:()
另一种有序列表叫元组：tuple。tuple和list非常类似，
但是tuple一旦初始化就不能修改，
定义一个空的tuple，可以写成()//t = ()
只有1个元素的tuple定义时必须加一个逗号,，来消除歧义
Python在显示只有1个元素的tuple时，也会加一个逗号,，
以免你误解成数学计算意义上的括号
tuple所谓的“不变”是说，tuple的每个元素，指向永远不变
---------------------------------------------------------
input()读取用户的输入，返回的数据类型是str
int()：把str转换成整数
int()函数发现一个字符串并不是合法的数字时就会报错，程序退出
---------------------------------------------------------------
range():生成一个整数序列
list():可以转换为list
----------------------------------------------------------
使用dict和set:
dict:{}
Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，
使用键-值（key-value）存储，有极快的查找速度
//d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，
这样，取的时候才能根据key直接拿到value。

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：//d['Adam'] = 67
由于一个key只能对应一个value，所以，多次对一个key放入value，
后面的值会把前面的值冲掉

要避免key不存在的错误，有两种办法，一是通过in判断key是否存在// 'Thomas' in d
二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value
>>> d.get('Thomas')
>>> d.get('Thomas', -1)
-1
//注意：返回None的时候Python的交互环境不显示结果。

要删除一个key，用pop(key)方法，对应的value也会从dict中删除//d.pop('Bob')

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在
正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。
这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出
的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为
哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、
整数等都是不可变的，因此，可以放心地作为key。而list是可变的，
就不能作为key
================
set：() [] {}
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，
所以，在set中，没有重复的key。
要创建一个set，需要提供一个list作为输入集合

重复元素在set中自动被过滤

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果

通过remove(key)方法可以删除元素

set可以看成数学意义上的无序和无重复元素的集合，
因此，两个set可以做数学意义上的交集、并集等操作

set和dict的唯一区别仅在于没有存储对应的value，
但是，set的原理和dict一样，所以，同样不可以放入可变对象，
因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”

不可变对象：
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。
相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的

list:sort()函数
str:replace()函数

---------------
------------------
---
函数：
绝对值的函数abs
在交互式命令行通过help(abs)查看abs函数的帮助信息
ax函数max()可以接收任意多个参数，并返回最大的那个
Python内置的常用函数还包括数据类型转换函数：
int() 	float() str() bool() 
hex()函数把一个整数转换成十六进制表示的字符串


函数名其实就是指向一个函数对象的引用，
完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

函数定义：
	在Python中，定义一个函数要使用def语句，
	依次写出函数名、括号、括号中的参数和冒号:，
	然后，在缩进块中编写函数体，函数的返回值用return语句返回
	
	函数可以同时返回多个值，但其实就是一个tuple。
	在语法上，返回一个tuple可以省略括号
	
在Python交互环境中定义函数时，注意Python会出现...的提示。
函数定义结束后需要按两次回车重新回到>>>提示符下

空函数：如果想定义一个什么事也不做的空函数，可以用pass语句
def nop():
    pass
	
如果你已经把my_abs()的函数定义保存为abstest.py文件了，
那么，可以在该文件的当前目录下启动Python解释器，
用from abstest import my_abs来导入my_abs()函数，
注意abstest是文件名（不含.py扩展名）
---
0318：
函数的参数：
	使用默认参数、可变参数和关键字参数
	位置参数
	默认参数//类似C++ 的
	一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
	二是如何设置默认参数。

	当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数
	
	定义默认参数要牢记一点：默认参数必须指向不变对象！！！！！
	
	为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，
	对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。
	此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。
	我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象
----
	可变参数：常见！！！
	可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple
	
	这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，
	把list或tuple的元素变成可变参数传进去：
>>> nums = [1, 2, 3]
>>> calc(*nums)
14
	*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。
----
	关键字参数：
	可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传
	可以用简化的写法
	和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数
	如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了
	
	命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错
	命名关键字参数可以有缺省值，从而简化调用：
	由于命名关键字参数city具有默认值，调用时，可不传入city参数
	
	使用命名关键字参数时，要特别注意，如果没有可变参数，
	就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数
	
	参数组合：
	参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，
这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、
命名关键字参数和关键字参数
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

递归函数：
	使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

	针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

	Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题
	
	
	
	
	
	
	



