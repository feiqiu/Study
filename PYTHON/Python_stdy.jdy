
---
Python基础：
Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素
len()函数:获得list元素的个数
用索引来访问list中每一个位置的元素，索引从0开始// classmates[0]
可以用-1做索引，直接获取最后一个元素,并以此类推//classmates[-1] classmates[-2]  ....
append():往list中追加元素到末尾//classmates.append('Adam')
insert():把元素插入到指定的位置，比如索引号为1的位置// classmates.insert(1, 'Jack')
pop():删除list末尾的元素,删除指定位置的元素，用pop(i)方法，其中i是索引位置
要把某个元素替换成别的元素，可以直接赋值给对应的索引位置
list里面的元素的数据类型也可以不同// L = ['Apple', 123, True]
list元素也可以是另一个list //list元素也可以是另一个list  //也就是多维数组,///可以拆开写
如果一个list中一个元素也没有，就是一个空的list，它的长度为0 //L = []
jdy:list中括号[]
====================================
tuple:()
另一种有序列表叫元组：tuple。tuple和list非常类似，
但是tuple一旦初始化就不能修改，
定义一个空的tuple，可以写成()//t = ()
只有1个元素的tuple定义时必须加一个逗号,，来消除歧义
Python在显示只有1个元素的tuple时，也会加一个逗号,，
以免你误解成数学计算意义上的括号
tuple所谓的“不变”是说，tuple的每个元素，指向永远不变
---------------------------------------------------------
input()读取用户的输入，返回的数据类型是str
int()：把str转换成整数
int()函数发现一个字符串并不是合法的数字时就会报错，程序退出
---------------------------------------------------------------
range():生成一个整数序列
list():可以转换为list
----------------------------------------------------------
使用dict和set:
dict:{}
Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，
使用键-值（key-value）存储，有极快的查找速度
//d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，
这样，取的时候才能根据key直接拿到value。

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：//d['Adam'] = 67
由于一个key只能对应一个value，所以，多次对一个key放入value，
后面的值会把前面的值冲掉

要避免key不存在的错误，有两种办法，一是通过in判断key是否存在// 'Thomas' in d
二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value
>>> d.get('Thomas')
>>> d.get('Thomas', -1)
-1
//注意：返回None的时候Python的交互环境不显示结果。

要删除一个key，用pop(key)方法，对应的value也会从dict中删除//d.pop('Bob')

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在
正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。
这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出
的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为
哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、
整数等都是不可变的，因此，可以放心地作为key。而list是可变的，
就不能作为key
================
set：() [] {}
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，
所以，在set中，没有重复的key。
要创建一个set，需要提供一个list作为输入集合

重复元素在set中自动被过滤

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果

通过remove(key)方法可以删除元素

set可以看成数学意义上的无序和无重复元素的集合，
因此，两个set可以做数学意义上的交集、并集等操作

set和dict的唯一区别仅在于没有存储对应的value，
但是，set的原理和dict一样，所以，同样不可以放入可变对象，
因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”

不可变对象：
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。
相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的

list:sort()函数
str:replace()函数

---------------
------------------
---
函数：
绝对值的函数abs
在交互式命令行通过help(abs)查看abs函数的帮助信息
ax函数max()可以接收任意多个参数，并返回最大的那个
Python内置的常用函数还包括数据类型转换函数：
int() 	float() str() bool() 
hex()函数把一个整数转换成十六进制表示的字符串


函数名其实就是指向一个函数对象的引用，
完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

函数定义：
	在Python中，定义一个函数要使用def语句，
	依次写出函数名、括号、括号中的参数和冒号:，
	然后，在缩进块中编写函数体，函数的返回值用return语句返回
	
	函数可以同时返回多个值，但其实就是一个tuple。
	在语法上，返回一个tuple可以省略括号
	
在Python交互环境中定义函数时，注意Python会出现...的提示。
函数定义结束后需要按两次回车重新回到>>>提示符下

空函数：如果想定义一个什么事也不做的空函数，可以用pass语句
def nop():
    pass
	
如果你已经把my_abs()的函数定义保存为abstest.py文件了，
那么，可以在该文件的当前目录下启动Python解释器，
用from abstest import my_abs来导入my_abs()函数，
注意abstest是文件名（不含.py扩展名）
---
0318：
函数的参数：
	使用默认参数、可变参数和关键字参数
	位置参数
	默认参数//类似C++ 的
	一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
	二是如何设置默认参数。

	当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数
	
	定义默认参数要牢记一点：默认参数必须指向不变对象！！！！！
	
	为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，
	对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。
	此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。
	我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象
----
	可变参数：常见！！！
	可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple
	
	这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，
	把list或tuple的元素变成可变参数传进去：
>>> nums = [1, 2, 3]
>>> calc(*nums)
14
	*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。
----
	关键字参数：
	可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传
	可以用简化的写法
	和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数
	如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了
	
	命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错
	命名关键字参数可以有缺省值，从而简化调用：
	由于命名关键字参数city具有默认值，调用时，可不传入city参数
	
	使用命名关键字参数时，要特别注意，如果没有可变参数，
	就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数
	
	参数组合：
	参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，
这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、
命名关键字参数和关键字参数
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

递归函数：
	使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

	针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

	Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题
	

--------------
2018-0520
pass用来作占位符

数据类型检查可以用内置函数isinstance()

raise函数
在Python中，要想引发异常，最简单的形式就是输入关键字raise，后跟要引发的异常的名称。
异常名称标识出具体的类： Python异常处理是那些类的对象。
Python 异常处理--raise函数用法 - 你若精彩，蝴蝶自来 - 博客园
https://www.cnblogs.com/caicaihong/p/6402245.html

函数的参数
	位置参数
	必选参数外，还可以使用默认参数、可变参数和关键字参数
	必选参数、默认参数、可变参数、关键字参数和命名关键字参数
	请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
	
	必选参数在前，默认参数在后
	
	当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。
	变化小的参数就可以作为默认参数。
	
	定义默认参数要牢记一点：默认参数必须指向不变对象！
	
	关键字参数允许你传入0个或任意个含参数名的参数，
	这些关键字参数在函数内部自动组装为一个dict。
	
	定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。
	
	
	==============================================
	0521
	切片
		取指定索引范围的操作，用切片(slice)
		
		倒数第一个元素的索引是-1
		
		切片应用：list,tuple,字符串
		
		字符串截取用切片
		
		切片的切片：
			前10个数，每两个取一个
			L[:10:2]
			
		str的strip()方法:
		str.strip()就是把这个字符串头和尾的空格，以及位于头尾的\n \t之类给删掉。
		python中字符串str的strip()方法 - CSDN博客
		https://blog.csdn.net/u012671171/article/details/52024874
==============================================
迭代(iteration)
	迭代对象：list,tuple,dict,字符串等
	
	默认情况下，dict迭代的是key。
	如果要迭代value，可以用for value in d.values()，
	如果要同时迭代key和value，可以用for k, v in d.items()。
	
	如何判断一个对象是可迭代对象呢？
	方法是通过collections模块的Iterable类型判断：
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代 

	Python内置的enumerate函数可以把一个list变成索引-元素对，
	这样就可以在for循环中同时迭代索引和元素本身

====================20180603======================
(列表生成式)List Comprehensions

	列表生成式用一行语句循环生成list
	使用内建的isinstance函数判断一个变量是不是字符串：
	>>>isinstance(x, str)
	
	列表生成式也可以使用两个变量来生成list
	
	运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list
	
====================20180603======================
生成器(genertor)
	在Python中，这种一边循环一边计算的机制，称为生成器：generator。
	
	方法一：把一个列表生成式的[]改成()
	
	通过next()函数获得generator的下一个返回值
	
	方法二：一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，
	而是一个generator。
	
	函数是顺序执行，遇到return语句或者最后一行函数语句就返回。
	而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，
	再次执行时从上次返回的yield语句处继续执行。
	
	请注意区分普通函数和generator函数，普通函数调用直接返回结果，
	generator函数的“调用”实际返回一个generator对象。
	
	
====================20180603======================
迭代器(Iterator)	
	一类是集合数据类型，如list、tuple、dict、set、str等
	一类是generator，包括生成器和带yield的generator function。
	可以直接作用于for循环的对象统称为可迭代对象：Iterable。
	
	使用isinstance()判断一个对象是否是Iterable对象
	>>> from collections import Iterable
	>>> isinstance([], Iterable)
	
	可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。
	>>> from collections import Iterator
     >>> isinstance((x for x in range(10)), Iterator)
	
	生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

	把list、dict、str等Iterable变成Iterator可以使用iter()函数：
	>>> isinstance(iter([]), Iterator)
	>>> isinstance(iter('abc'), Iterator)
	

====================20180711======================
面向对象编程：
	///变量与函数，属性与方法，特征与行为
	类与实例
	
		类的关键字
		定义类的格式
		怎么创建实例？//具体对象，实例变量
		///!!!python可以自由地给一个实例变量绑定属性
		绑定属性，__init__  方法使用///实例变量self  : this指针
		__init__  方法///构造函数及初始化列表
		
		类的方法的格式
		
		静态语言不同，Python允许对实例变量绑定任何数据，也就是说，
		对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同
	
	
	访问限制
		
		私有(private)属性：变量名以__开头
		访问私有属性的方式
		
		在方法中，可以对参数做检查，避免传入无效的参数
		
		在Python中，变量名类似__xxx__的，也就是以双下划线开头，
		并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的
		
		以一个下划线开头的实例变量名：可以被访问，但视为私有变量，不要随意访问
		
		不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，
		所以，仍然可以通过_Student__name来访问__name变量：

	继承与多态
	
		判断一个变量是否是某个类型可以用isinstance()判断
		
		开闭原则：对扩展开放，对修改封闭
		
		静态语言 VS 动态语言
		S:类型严格匹配
		D：一定有调用方法
		
		鸭子类型：file-like object
		
	获取对象信息
		是什么类型，有哪些方法
		
		type()判断基本类型，函数，类
		
		
		判断一个对象是否是函数：用types模块中定义的常量
		type()不适合继承，判断class的类型，可以使用isinstance()函数
		
		使用isinstance()判断一个变量是否是某些类型中的一种
		
		获得一个对象的所有属性和方法，可以使用dir()函数
		
		getattr()、setattr()以及hasattr()
		
		要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写	
		
	实例属性和类属性
		类属性：static

=========================0718===========================================
定义一个特殊的__slots__变量，来限制该class实例能添加的属性
__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的

python 的@的关键字符
装饰器（decorator）可以给函数动态加上功能
Python内置的@property装饰器就是负责把一个方法变成属性调用的   ///函数指针
定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性
@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。


===============0729========================
错误、调试和处理
	错误处理
		try……except……finally错误处理机制
		
		Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系看这里：
		https://docs.python.org/3/library/exceptions.html#exception-hierarchy
		
		使用try...except捕获错误好处：可以跨越多层调用
		
		调用栈：
		分析错误出处
		
		记录错误：
		内置logging模块
		
		通过配置，logging还可以把错误记录到日志文件里，方便事后排查。
		
		抛出错误：
		raise语句抛出错误的实例
		抛出自定义错误
		
		raise语句如果不带参数，就会把当前错误原样抛出。
		//处理不了的错误，就一直往上抛
		在except中raise一个Error，还可以把一种类型的错误转化成另一种类型
		