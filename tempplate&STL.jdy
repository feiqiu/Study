//-------------------------------------------20171129--------------------------------------------------------------
计算机的核心思想：数据类型(内存的分配)，逻辑运算处理
模板：类型参数化，对类型的抽象化，更高一层的抽象，或者说内存分配的抽象，跟高级的抽象
由宏引入模板，模板
模板的格式：再抽象，更加抽象出来;函数的思想：类型实参，类型形参？
类型，模板

语法：
template <typename 类型参数1，typename 类型参数2，...> //尖括号里是类型参数表，每个类型参数由关键字typename引导
例如：
	template <typename A,template b,template _C> //习惯用T或者t来表示类型参数
	A function (b arg)
	{
		_C var;
		...
	}

函数模板 ：模板在函数中应用
模板实例化：需要注意一些问题
	怎么实例化：
	函数模板名<类型实参1，类型实参2，...> (调用实参表)；
	::max<int> (123,456);
	/*
		max<int>  紧挨着写，空格(调用实参表)，写法严格按照要求写
		类型实参表一定要位于函数模板名和调用实参表之间
		函数模板名和类型实参表看做一个整体，所以把它们紧挨着写，相当于函数模板名加上类型实参表才看作一个具体函数的函数名
		
		函数模板的类型实参放在尖括号中，调用实参表放在圆括号中，且类型实参表必须位于函数模板名和调用实参表之间
		有时候函数模板的类型实参表或调用实参表可以为空，但尖括号和圆括号不能不写！！！！！
	*/
	函数模板二次编译：
	
	----------------------------------------------------------------------------------------- 	
类模板：在声明类应用
	有类型都可以用模板
	template<typename T>
	class Comparator{
		public:
		Comparator (T x,T y):m_x(x),m_y (y){}
		T max(void)const
		{
			return m_x < m_y? m_y:m_x;
		}
		T min(void)const
		{
			return m_x > m_y? m_y:m_x;
		}
		private:
		T m_x:
		T m_y:
	};
	
	//这三个是不是用得太复杂
	类类型里面嵌套函数模板？？
	函数里面嵌套类模板？？？
	类模板与函数模板互相嵌套？？？
	模板和宏区别：
//------------------------------------------------------------------------------------------------------------

模板：类型参数化		//!!!!!!!!!!!可以是基本类型，类类型，用他们去实例化类型参数
							//注意：所使用的类型必须能满足该模板所需的操作
类型抽象
语言中立
系统中立
编译中立
通用型

 猜类型：隐式推断：简化代码，有风险
 类型一致
 限制：
 三种不能隐式推断 
 
 数组名：二义性 
 隐式推断不能和隐式转换同时发生
 只有函数参数能隐式推断
 函数返回值不能隐式推断
 
 重载：作用域相同
 
 函数模板的重载 
 
 
 特殊优先原则
 类型安全
 最小工作量
 
 
 重载解析在  第一次编译 可见
 重载
 在函数模板的实例化函数中，同样优先选择普通函数，
 但是一定要保证该函数在函数模板被第一次编译时就可见，
 因为重载候选方案在函数模板第一次编译产生。
 
 为什么C++有函数重载？
 
 函数模板
 类模板
 
 逆多态，基类参数化
 多爹，换爹
 两步实例化
 模板类->类(具体类)->对象
 模板类：设计阶段
 编译阶段
 运行阶段
 
 
 
 