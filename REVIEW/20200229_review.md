----

1.证明大小端问题？

大同小异

0x12345678

打印输出是相同的是大端，打印出0x12 0x34 0x56 0x78，所以大同

打印输出是差异的是小段，打印出0x78 0x56 0x34 0x12，所以小异

大端：高位低字节(低地址)

小端：高位高字节(高地址)

```C
#include <stdio.h>
union System
{
	char a;
	int b;
};
 
int main()
{
    union System s;
	s.b = 1;
	
	printf("0x%x\n",&s.a);
	printf("0x%x\n",&s.b);
	
	if(s.a == 1)
	{
		printf("Little-endian\n");
	}
	else
	{
		printf("Big-endian\n");
	}
	  
    return 0;
}
```

(1条消息)面试题：C语言验证大小端的几个方法_嵌入式资讯精选-CSDN博客 - https://blog.csdn.net/DP29syM41zyGndVF/article/details/103640847

---

2.struct 对齐补齐

---

3.死锁是怎么造成的？如何避免死锁？

什么是死锁？怎么防止死锁？ - https://mp.weixin.qq.com/s/yVM1KJ-vHabte72iXLsy1g什么是死锁？怎么防止死锁？

一、定义

死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

二、产生条件：

1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

三、产生原因：

1、竞争资源引起进程死锁

2、可剥夺资源和不可剥夺资源

3、竞争不可剥夺资源

4、竞争临时资源

四、如何避免（预防）和解决死锁：

A.预防

a.打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。

b.打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。

c.打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。

d.打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。

如：有序资源分配法、银行家算法

B.解决方法

a.进行系统的重新启动

b.撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。

c.进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。

---------------------

IPC：inter-processer communication 进程间通信有？

进程间通信 （IPC） 方法总结 (一) - 12oz - 博客园 - https://www.cnblogs.com/joker-wz/p/11000489.html

进程间通信 （IPC） 方法总结（二） - 12oz - 博客园 - https://www.cnblogs.com/joker-wz/p/11006414.html

进程间通信 （IPC） 方法总结（三） - 12oz - 博客园 - https://www.cnblogs.com/joker-wz/p/11013086.html

消息队列，											·管道/匿名管道，socket，信号，信号量，共享内存