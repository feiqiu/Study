进程是资源分配的最小单位，线程是CPU调度的最小单位；进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂

Linux进程与线程的区别 - laviolette的专栏 - CSDN博客
https://blog.csdn.net/laviolette/article/details/51506953

讲讲多线程与多进程的区别，在什么时候用线程或进程更合适?
【转】多进程 & 多线程的区别与适用场景
http://www.mamicode.com/info-detail-252716.html

关于多进程和多线程，教科书上最经典的一句话是“进程是资源分配的最小单位，线程是CPU调度的最小单位”，这句话应付考试基本上够了，但如果在工作中遇到类似的选择问题，那就没有这么简单了，选的不好，会让你深受其害。
经常在网络上看到有的XDJM问“多进程好还是多线程好？”、“Linux下用多进程还是多线程？”等等期望一劳永逸的问题，我只能说：没有最好，只有更好。根据实际情况来判断，哪个更加合适就是哪个好。
我们按照多个不同的维度，来看看多线程和多进程的对比（注：因为是感性的比较，因此都是相对的，不是说一个好得不得了，另外一个差的无法忍受）。


看起来比较简单，优势对比上是“线程 3.5 v 2.5 进程”，我们只管选线程就是了？
呵呵，有这么简单我就不用在这里浪费口舌了，还是那句话，没有绝对的好与坏，只有哪个更加合适的问题。我们来看实际应用中究竟如何判断更加合适。
1）需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）
原因请看上面的对比。
这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的
2）需要进行大量计算的优先使用线程（CPU频繁切换）
所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
这种原则最常见的是图像处理、算法处理。
3）强相关的处理用线程，弱相关的处理用进程
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。
一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。
当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。
4）可能要扩展到多机分布的用进程，多核分布的用线程
原因请看上面对比。
5）都满足需求的情况下，用你最熟悉、最拿手的方式
至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。
需要提醒的是：虽然我给了这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。

//------------------------------------------------------------------
阻塞与非阻塞：
1、connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？
答:最通常的方法最有效的是加定时器；也可以采用非阻塞模式。
//------------------------------------------------------------------

孤儿进程与僵尸进程[总结] - Anker's Blog - 博客园
http://www.cnblogs.com/Anker/p/3271773.html

僵尸进程：如果子进程先终止，但其父进程没有为它调用 wait()函数，那么该子进
程就会变为僵尸进程。僵尸进程在它的父进程为它调用 wait()函数之前将一直占有
系统的内存资源。
如果子进程先结束，但是父进程由于各种原因并没有收到子进程发来的信号，也就是没有帮助子进程回收资源，那么子进程会变成僵尸进程。
孤儿进程：如果父进程先终止，尚未终止的子进程将会变成孤儿进程。孤儿进程将
直接被 init 进程收管，由 init 进程负责收集它们的退出状态。

如果父进程不需要通过pid管理子进程，那么fork一次，然后wait，再让fork出来的子进程fork一个孙子进程出来，然后子进程自杀，然后父进程通过wait回收子进程，此时孙子进程直接被init进程收养，死了自动回收。如果需要通过pid管理，那只能用waitpid之类的调用来人为回收结束的子进程

1）父进程先于子进程终止：
此种情况就是我们前面所用的孤儿进程。当父进程先退出时，系统会让init进程接管子进程 。

2）子进程先于父进程终止，而父进程又没有调用wait或waitpid函数
此种情况子进程进入僵死状态，并且会一直保持下去直到系统重启。子进程处于僵死状态时，内核只保存进程的一些必要信息以备父进程所需。此时子进程始终占有着资源，同时也减少了系统可以创建的最大进程数。

僵死状态：一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息，释放它仍占有的资源)的进程被称为僵死进程(zombie)。ps命令将僵死进程的状态打印为Z 。

3）子进程先于父进程终止，而父进程调用了wait或waitpid函数 
此时父进程会等待子进程结束。

僵尸进程：
为什么有僵尸进程：
	defunct进程不仅占用系统的内存资源，影响系统的性能，而且如果其数 目太多，还会导致系统瘫痪

怎么查看僵尸进程：ps -ef | grep defunct
怎么解决僵尸进程：杀掉父进程即可清理该僵尸进程
	
	defunct进程是不能直接kill -9杀掉的，否则就不叫僵尸进程了
	
	1，重启服务器电脑，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。
	  所以，尽量使用下面一种方法。

	2，找到该defunct僵尸进程的父进程，将该进程的父进程杀掉，则此defunct进程将自动消失

	   找到defunct僵尸进程的父进程：ps -ef | grep defunct_process_pid
	   
	   kill -9 `ps -ef | grep defunct_process_pid`
	   
编写一unix程序，防止僵尸进程的出现.
方法一：	处理父进程的SIGCHLD信号，在信号处理函数里用wait或者waitpid等函数进行处理。
方法二：A fork B, B fork C, 然后结束B. C变成孤独进程,会被init进程接收. 
	SIGCHLD，在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号，
	如果父进程希望被告知其子系统的这种状态，则应捕捉此信号。
	
	如果父进程不需要通过pid管理子进程，那么fork一次，然后wait，再让fork出来的子进程fork一个孙子进程出来，然后子进程自杀，然后父进程通过wait回收子进程，此时孙子进程直接被init进程收养，死了自动回收。如果需要通过pid管理，那只能用waitpid之类的调用来人为回收结束的子进程
	

作者：Skillness
链接：https://www.zhihu.com/question/29378056/answer/44159959
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	
linux下如何防止僵尸进程的出现？？-CSDN论坛
http://bbs.csdn.net/topics/350176524?locationNum=13

Unix/Linux系统中僵尸进程是如何产生的？有什么危害？如何避免？ - NewPanderKing - 博客园
http://www.cnblogs.com/newpanderking/p/3784328.html

僵死进程（1）：如何防止僵尸进程的出现？ - 初来 - 博客园
http://www.cnblogs.com/bitter-first-sweet-last/p/3947777.html

如何编写unix 程序防止僵尸进程的出现？ - 知乎
https://www.zhihu.com/question/29378056

系统为什么不直接回收僵尸进程：

//--------------------------------------------------------------------
守护进程（Daemon）：是Linux中的后台服务进程。他是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。
守护进程在系统启动时开始运行，系统关闭时终止

Daemon程序实现方法
　　编写Daemon程序有一些基本的规则，以避免不必要的麻烦。
　　1、首先是程序运行后调用fork，并让父进程退出。子进程获得一个新的进程ID，但继承了父进程的进程组ID。
　　2、调用setsid创建一个新的session，使自己成为新session和新进程组的leader，并使进程没有控制终端(tty)。
　　3、改变当前工作目录至根目录，以免影响可加载文件系统。或者也可以改变到某些特定的目录。
　　4、设置文件创建mask为0，避免创建文件时权限的影响。
　　5、关闭不需要的打开文件描述符。因为Daemon程序在后台执行，不需要于终端交互，通常就关闭STDIN、STDOUT和STDERR。其它根据实际情况处理。
　　另一个问题是Daemon程序不能和终端交互，也就无法使用printf方法输出信息了。我们可以使用syslog机制来实现信息的输出，方便程序的调试。在使用syslog前需要首先启动syslogd程序，关于syslogd程序的使用请参考它的man page，或相关文档，我们就不在这里讨论了。
//----------------------------------------------------------------------


程序：主要指存储在磁盘上的代码文件
进程：主要指在内存中运行的程序
线程主要用于在一个进程的内部并行（同时执行）多段代码。
线程可以理解为进程中的执行的一段程序片段

进程在系统内存的分配：
进程在内存空间中的布局形成进程映像，从低地址到高地址依次为

代码区(text)：其中存放的是可执行指令、字面值常量、具有常属性且被初始化的全局变量和静态局部变量（代码区和只读常量区）。

数据区(data)：其中存放的是不具有常属性且被初始化的全局变量和静态局部变量。
																										（全局区）
BSS区(bss)：其中存放的是未被初始化的全局变量和静态局部变量。Block Started  Symbol

堆区(heap)：其中存放的是动态分配内存。

栈区(stack)：其中存放的是非静态局部变量(函数的形参，局部变量，常属性的局部变量)。

参数和环境区：其中存放的是命令行参数和环境变量。

谈谈进程与线程的理解
1、进程：主要指在内存中运行的程序
线程：可以理解为进程中的执行的一段程序片段
线程主要用于在一个进程的内部并行（同时执行）多段代码。

2、线程是处理器调度的基本单位, 进程是资源分配和拥有的基本单位。
系统资源开销：进程是重量级的，创建进程系统需要分配独立内存空间（0~3G）；
线程是轻量级的，每个线程创建都共享所在进程的除了栈区的内存资源（除了栈区，共享代码段，全局区，文件状态等等），但是每个线程会额外增加一个很小的线程相关的栈空间。

3、并发性：进程之间可以并发执行，同一个进程的多个线程之间也可并发执行


线程相关函数：
pthread_create();//启动新线程
pthread_self();//获取正在调用线程的ID
pthread_join();//等待指定线程终止，并获取退出状态信息
pthread_detach();//指定线程标记为分离状态
pthread_exit();//终止当前正在运行的线程…………
pthread_cancel();//
pthread_setcancelstate();//
pthread_setcanceltype();
-----------------------------------------
实现线程同步的基本思想：让多线程分别串行访问共享资源
1、使用互斥量（互斥锁）
	a.定义互斥量pthread_mutex_t mutex;
	b.初始化互斥量pthread_mutex_init(&mutex);
	c.使用互斥量对共享资源的访问进行加锁
	d.访问共享资源
	e.使用互斥量对共享资源的访问进行解锁pthread_mutex_unlock(&mutex);
	f.不使用，则销毁互斥量pthread_mutex_destroy(&mutex);
	
2、使用信号量

3、使用条件变量（生产者与消费者模型）
线程之间步调协调问题
异步线程
同步线程
生产者――消费者模型

生产者：产生资源（数据）的线程，如客户线程
消费者：消耗资源（数据）线程，如存储线程
生产快于消费，缓冲区满，撑死。
消费快于生产，缓冲区空，饿死。

一旦缓冲区满，就应该让生产者停止生产，直到消费者有所消费，
再恢复生产；一旦缓冲区空，就应该让消费者停止消费，直到生产有所
生产，再恢复消费。

当某个条件不被满足时就等待，一旦条件满足就通知处于等待状态的过程
恢复――条件变量。

1、初始化
int  pthread_cond_init(pthread_cond_t* cond,
      pthread_condattr* attr);
或者      
pthread_cond_t  cond=PTHREAD_COND_INITIALIZER;
2、终结化
int  pthread_cond_destrory(pthread_cond_t* cond);
3、等待
int pthread_cond_wait(pthread_cond_t* cond,
      pthread_mutex_t* mutex);
使调用线程进入睡眠状态，同时释放指定互斥锁。
4、唤醒
int pthread_cond_signal(pthread_cond* cond);
将任意一个在条件变量中处于睡眠状态的线程唤醒。被唤醒的
线程只有重新获得了先前的互斥锁，才能从pthread_cond_wait函
数中返回。
int pthread_cond_broadcast(pthread_cond_t* cond);
将在指定条件变量中处于睡眠状态的所有的线程统统唤醒，但是只
有重新得到互斥锁的线程才会从pthread_cond_wait函
数中返回。 
范例 cond.c

-----------------------------------------





线程的原理：
	进程和线程的关系：
	 进程就是程序需要执行的各种资源，线程就是执行过程中的代码（CPU调度）
	 操作系统支持多进程，每个进程内部支持多线程。其中有一个是主线程（main函数），其他的线程都是由主线程直接/间接启动。
	如果一个进程中主线程结束，进程随之结束，其他线程也随之结束。
	线程主要用于在一个进程的内部并行（同时执行）多段代码。
	线程：是轻量级的，不拥有自己独立的内存资源，而是共享进程的内存资源（代码段，全局区，文件状态等等）每个线程只是额外增加一个线程相关的栈空间
	进程：是重量级（0~3G），拥有自己独立的内存空间	


	线程是实现并发的必要条件
	线程ID
	每个线程都有自己唯一的线程ID

1．进程和线程的差别。
线程是指进程内的一个执行单元,也是进程内的可调度实体.
与进程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。




1. 进程和线程的区别
什么是进程（Process）：普通的解释就是，进程是程序的一次执行，而什么
是线程（Thread），线程可以理解为进程中的执行的一段程序片段。
在一个多任务环境中下面的概念可以帮助我们理解两者间的差别：
进程间是独立的，这表现在内存空间，上下文环境；
线程运行在进程空间内。
一般来讲（不使用特殊技术）进程是无法突破进程边界存取其他进程内的存储空间；

而线程由于处于进程空间内，所以同一进程所产生的线程共享同一内存空间。同一进程中的两段代码不能够同时执行，除非引入线程。

线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。

线程占用的资源要少于进程所占用的资源。 进程和线程都可以有优先级。
在线程系统中进程也是一个线程。可以将进程理解为一个程序的第一个线程。
线程是指进程内的一个执行单元,也是进程内的可调度实体.
与进程的区别:
(1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的
地址空间;而进程有自己独立的地址空间;
(2)进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
(3)线程是处理器调度的基本单位,但进程不是.
(4)二者均可并发执行


程序与进程：
程序：主要指存储在磁盘上的代码文件。
进程：主要指在内存中运行的程序。


49.static有什么用途？（请至少说明两种）
答 1.限制变量的作用域(文件级的)。
    2.设置变量的存储域(全局数据区)
在C语言中，static通常有2种含义：
1）定义变量的生命周期；
2）定义变量或者函数的作用域。
变量的生命周期是指，相对于程序运行的进程生命周期，变量存在的时间段。变量的生命周期由变量的存储类型（位置）决定。因此static的第1种含义也可以理解为，static定义了变量的存储类型（位置）。
C语言中，变量存储位置分为栈、全局静态区、堆。栈用来做函数调用，参数传递等，在程序的运行过程中是操作最频繁的数据区。全局静态区，是变量一直存在于内存中，在程序整个运行过程中不会被销毁。堆，是由操作系统维护的大空间内存伸缩区，进程可以主动向操作系统申请使用堆的存储，在程序运行过程中动态申请。
由static修饰的变量，其存储类型为全局静态区，变量在程序的整个运行过程中不会被销毁，并且只会被初始化1次。
代码1：static修饰变量的生命周期（存储类型）
 
void func1()
{
    static int var1 = 1;        // 在全局静态区分配变量var1的存储空间
    int var2 = 1;        // 在栈上分配var2的存储空间

    var1 = var1+1;    
    var2 = var2+1;

    printf("var1=%d, var2=%d", var1, var2)
}

void main()
{
    func1();
    func1();
    func1();
}
 
代码输出：
“var1=2, var2=2”
“var1=3, var2=2”
“var1=4, var2=2”
作用域是指变量/函数的可见区域，可被引用区域。在C语言中，不加static修饰的函数对所有的源文件都是可见的，不加static修饰的全局变量对所有的源文件都是可见的。通过static修饰，可以把函数的作用域限定在本源文件内，把全局变量的作用域限定在本源文件内。
由于全局变量和函数的作用域是所有源文件，所有源文件引用的是同一个全局变量和函数，因此C语言不允许在2个源文件内定义相同的全局变量、函数，在代码链接阶段会提示链接错误。通过添加static修饰，可以让2个源文件定义相同的全局变量和函数，但是注意这2个源文件引用的全局变量和函数是独立的。
static常见使用场合
 
static int var1 = 1;       // 限定全局变量var1仅在本源文件可见
static void func1()        // 限定函数仅在本源文件可见
{
    static int var2 =1;     // var2是静态变量，不是栈变量，只被初始化一次
}       

void main()
{
    func1();
}


10 static 全局变量与普通的全局变量有什么区别？static 局部变量和普通局部变量有什么区别？static 函数与普通函数有什么区别？
答: 1) 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。
全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并
无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源
文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其
作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由
于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避
免在其它源文件中引起错误。
2) 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变
了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范
围。
3) static 函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，

内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，

要使用这些函数的源文件要包含这个头文件
综上所述:
static 全局变量与普通的全局变量有什么区别：
static 全局变量只初使化一次，防止在其他文件单元中被引用;

static 局部变量和普通局部变量有什么区别：
static 局部变量只被初始化一次，下一次依据上一次结果值；可以返回其地址 其值不可以改 
static 函数与普通函数有什么区别：
static 函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 
这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各
个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全
局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。

static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。

对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件
 
static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
     在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
     在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
     static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
     static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
     static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝



37.简述数组与指针的区别？
　数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。
指针可以随时指向任意类型的内存块。
(1)修改内容上的差别char a[] = “hello”;a[0] = ‘X’;char *p = “world”; 
// 注意p 指向常量字符串p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，
而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，
该数组自动退化为同类型的指针。char a[] = "hello world";char *p = a;cout<< sizeof(a) << endl; // 12 字节
cout<< sizeof(p) << endl; // 4 字节
计算数组和指针的内存容量
void Func(char a[100]){cout<< sizeof(a) << endl; // 4 字节而不是100 字节}

31.解释堆和栈的区别。
栈区（stack）―   由编译器自动分配释放，存放函数的参数值，局部变量的值等。
堆:一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。


1.
assert 
语法:
   #include <assert.h>  
  void assert( int exp ); 
功能： 宏assert()用于错误检测。如果表达式的结果为零，宏写错误信息到STDERR并退出程序执行。
如果宏NDEBUG已经定义，宏assert()将被忽略。 
 
2.
const int a; 
int const a; 
const int *a; 
int * const a; 
int const * a const;

void fun()const;
只读函数，不能修改成员变量，可以修改带关键字mutable的变量
 void fun();
3.
int main()
{
	int a[5]={1,2,3,4,5};
	int *ptr=(int*)(&a+1);//数组指针，类型强转  的考查
	cout<<*(a+1)<<" "<<*(ptr-1)<<endl;
	return 0;
}
输出结果是什么？    2  5
4.
char *pmsg = "A";
char msg[] = "A";
char ch    = 'A'; 
sizeof(pmsg) = 4
sizeof(msg)  = 2
sizeof(“A”)  = 2
sizeof(ch)   = 1
sizeof(‘A’)  = 4 （在C++中等于1） 
void f(char param[100])
{
 sizeof(param) = 4;
}

34.类成员函数的重载、覆盖和隐藏区别？
答案：
a.成员函数被重载的特征：
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无。
b.覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual 关键字。
c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）


11、 TCP/IP和OSI七层模型是如何划分的？各层的功能，这么设计有什么好处？
【考点】层次化软件设计保证可移植性。
分层模型最大的好处就是某一层变化了，只要其提供上层的接口未变，那么上层就无需做任何改动。
因此只需要更改本层的实现即可。嵌入式平台因为软硬件多变性，为了最大限度的利用先前的成果，
软件设计一定要遵循这种层次化模型，这样才能保证其可移植性

12、 TCP和UDP的区别？各种网络互连设备都用在哪一层？如何建立链接？如何进行拥塞控制？
【考点】协议设计可靠性及缓冲区设计管理。
TCP和UDP的最大区别在于可靠性，TCP通过三次握手协议及超时机制安全可靠的建立或者释放连接。
协议设计最大的问题就是如何保证效率合可靠性，TCP的设计为我们提供了一个参考。而滑动窗口机制可以有效的进行拥塞控制，但窗口大小的设计则关系到内存利用
率及缓冲效率可靠性等问题。在嵌入式的驱动程序设计中，经常会开辟缓冲区来进行流量控制及防止数据覆盖，缓冲区的大小设计则需要更加具体的应用情况设计才能
保证可靠性合灵活性


cp/udp是属于哪一层？tcp/udp有何优缺点？
答案：应用层表示层会话层运输层网络层物理链路层物理层 tcp /udp属于运输层 TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。
与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 
tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 udp: 不提供稳定的服务，包头小，开销小  


8:简述SPI,UART,I2C三种传输方式。
SPI：高速同步串行口，首发独立，可同步进行
     SPI接口主要应用在EEPROM，Flash，实时时钟，A/D转化器，数字信号处理，是一种全双工同步通讯总线，该接口一般使用四条线：串行时钟线（sck），主出从入线，主入从出线，低电平有效地的从机选择线。
I2C协议：是单片机与其他芯片进行通讯的协议：1：只要求两条总线线路，一条是串行时钟线，一条是串行数据线； 2：通过软件设定地址   3：是一个多主机总线，如果两个或更多主机同时初始化数据传送可通过冲突检测和仲裁防止数据破坏； 4：I2C总线传输的是数据的总高位
UART：主要是由一个modem（调制解调器），可以将模拟信号量转化成数字信号量。


21：进程和线程的区别：
1：调度：线程作为调度和分配的基本单元，进程作为拥有资源的基本单位；
2：并发性：不仅进程可以并发执行，同一进程内的线程也可以并发执行。
3：拥有资源：进程是拥有资源的基本独立单元，线程不拥有资源，但可以访问进程内的资源；
4：在创建或撤销线程时，由于系统都要为之分配和回收内存资源，导致系统的开销明显大于创建或撤销线程时的开销。 

在采用段式内存管理的架构中，数据段（data   segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。    
在采用段式内存管理的架构中，BSS段（bss   segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block   Started   by   Symbol的简称。BSS段属于静态内存分配。


【面试常见题目之后台知识】Linux多线程与多进程区别全方位解读+程序实例 - 滴水石穿 术业专攻 - CSDN博客
http://blog.csdn.net/Shijun_Zhang/article/details/7660719
