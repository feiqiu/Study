
a.	找出/tmp目录中，内容有hello world 的所有文件。
	grep -l ‘hello world’ /tmp/*
b.	找出/work目录中，文件后缀名为.cpp的所有文件。
   find /work *.cpp
c.	查看本机的当前网络连接状况。
   ifconfig
d.	查看当前系统中的所有进程。
   ps -aux

//-------------------------------------------------------------------
三.5、Makefile。(10分) 
如果有一个简单的Test项目目录如下： 
# tree Test 
Test 
|-- common.h 
|-- main.cpp 
|-- test.cpp 
`-- test.h 
  
1）使用wildcard、patsubst函数编写一个C++项目的Makefile文件 
source = $(wildcard *.cpp)
object = $(patsubst %.cpp, %.o, $(source)
all : main

%.o : %.cpp
	$(CXX) -c -o $@ $< $(CXXFLAGS)

main : $(object)
	$(CXX) -o $@ $(object) $(LIBS)
 
clean :
     -rm -rf $(object)
     -rm -rf main
     -rm -f *.[nes]
     -rm -f *.dx
 
   .PHONY : default clean
   
2）使用automake、autoconfig编写一个支持configure选项的configure.in脚本

//------------------------------------------------------------------------

4.	Linux下进程间通信的方式有哪几种？（4分）
   管道 信号量 内存共享 消息队列  套接字

10.	为使gdb可以调试可执行文件，需要在用g++/gcc编译时加入什么编译参数？(1分)
    加 ‘-g’参数
在一个可执行文件产生core文件后，如何使用gdb获知出错时的堆栈情况？（2分）（请给出gdb打开core文件的命令用法，及显示堆栈情况的命令）
	gdb filename core
	bt
如何在代码中打印出当前源文件名、行号？(1分)
	printf("%s――%d――%s\n",__FILE__,__LINE__,__FUNCTION__);分别代表文件，行号，函数名

1）编写一个脚本，统计一个目录下面所有C代码的行数。(2分) 
	wc -l `find ./ -name "*.c"`
2）编写一个sed脚本，去除HTML文件中的HTML标记。(2分) 
	sed -e 's#</?[^>]*>##g' filename
3）编写一个脚本获得当前系统eth0的IP地址。(2分) 
	ifconfig eth0 | grep "inet addr:" | awk '{print $2}' | cut -c 6-  (获取eth0网卡的IP地址)  
	或  
	ifconfig eth0 | grep "HWaddr" | awk '{print $5}'  (获取eth0网卡的MAC地址)
	
4）编写一个脚本以交互的方式，进行DNS的设定。(2分) 

5）使用ls命令编写一个脚本，实现ls -R，递归列出当前目录下的所有目录、文件。

6）----------------------------------------------------------- 
在一个目录下，找soft-link files，用下面的命令，原理是可行的，但无法操作， 
该如何解决？要2种方法。(2分) 
ls -l | grep -> 
  
7）----------------------------------------------------------- 
如何把标准错误输出，重定向到标准输出上。(2分) 
	2>&1  //&1:表明是标准输出而不是文件1
  
8）----------------------------------------------------------- 
我们的系统中的软件包是使用RPM管理的。要求下面的问题写出shell命令和运行结果。( 
  
5分) 
如何知道系统中安装了几个软件包。 rpm -qa
如何知道系统中安装了哪几类(group)软件包。 
如何知道kernel软件包的简述。 		rpm -i
如何知道kernel软件包的Changelog。 rpm -qpi kernel --changelog
如何知道kernel软件包有几个文件。 rpm -qlp kernel
如何知道kernel软件包安装后有多大。 
  
三.2、编辑工具的使用。(各2分) 
1）如何使用vi进行块拷贝、粘贴、删除的操作 
2）如何设置Tab的长度，以及自动缩进的长度 set tabstop=4    set shiftwidth=4
3）如何使用tag进行代码阅读 
4）如何在1～10行，有确认的进把所有的RedHat改为RedFlag :1,10s /RedHat/RedFlag/
5）在SourceNavigator中，如何跳到一个变量的声明处？如何得知光标当前的位置在那 
个函数体内？ 
  
三.3、编译器与调试器。(各2分) 
1）如何使用gcc得到宏展开的中间代码 
2）如何通过gcc在命令行中传入宏定义 
3）在那一级优化的情况下，内联函数才真正的内联到代码中 
4）gdb的watch命令如何使用，有何缺点 
5）gdb中使用什么命令可以显式调用的栈帧，如何查看某个栈帧上的局部变量 
6）如何使用gdb调试多进程 
7）如何使能/禁止core dump？ 
  
三.4、库。(各2分) 
1）如何知道XSetIMValues这个符号在那个X的库文件中 
2）如何读取C++的符号名，更具可读性 
3）请解释动态库的soname概念 
4）解释在链接时rpath选项的含义 


文件操作：

C++

嵌入式工程师笔试面试题目-kinghannah-ChinaUnix博客
http://blog.chinaunix.net/uid-24958038-id-3135809.html
12.Linux有内核级线程么。
答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两
种类型：“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序
中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度
和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现
，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。另外一
种则需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心，由内核的内部
需求进行创建和撤销，这两种模型各有其好处和缺点。用户线程不需要额外的内核开支
，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线
程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不
到运行的机会；而内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占
用了更多的系统开支。

8.CSingleLock是干什么的。
答：同步多个线程对一个数据类的同时访问

1. linux tty设备驱动体系结构。
2. epoll poll select 原理与逻辑实现。

3. 驱动中为什么引入并发和互斥机制？
	驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？ 并发（concurrency）指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问则很容易导致竞态（raceconditions）解决竞态问题的途径是保证对共享资源的互斥访问， 所谓互斥访问就是指一个执行单元 在访问共享资源的时候，其他的执行单元都被禁止访问。 访问共享资源的代码区域被称为临界区， 临界区需要以某种互斥机 制加以保护， 中断屏蔽， 原子操作，自旋锁，和信号量都是 linux 设备驱动中可采用的互斥途径。
	
	两个进程同时运行，就会产生并发问题。就像2人或10人同时涌到食堂窗口买饭一样，是客观存在的事情；
为了让大家有序买到食物，就必须排队，每次只有一人面对师傅卖食物，这就是互斥，每次只能一人；
拥有信号量的可以执行，没有拿到信号量的休眠等待，直到有人释放信号量。休眠期间，CPU可以调度执行其他进程；
自旋锁的情况，如果进程没拿到信号量，他就不停的自旋询问，直到信号量被释放，期间进程不休眠，因而CPU也不能执行其他进程。单CPU下，自旋发挥不了其特别作用。多CPU下，可以协调多CPU之间的资源共享。
哈，够显浅直白（重点是正确）了吧！

4. 如何优化嵌入式设备的启动速度？
5. 用两种方法实现二分查找算法。（递归和非递归）
6. WiFi 和WLAN的区别。
7. TCP中的keepalive机制。

linux驱动面试常见题目 - 老男孩 - CSDN博客
http://blog.csdn.net/rensanshi/article/details/9566283

linux驱动工程面试必问知识点 - OpenWrt/WLAN/驱动/嵌入式开发总结 - CSDN博客
http://blog.csdn.net/suiyuan19840208/article/details/20392151

4. 中断的上半部分和下半部分的问题：
讲下分成上半部分和下半部分的原因，为何要分？讲下如何实现？
上半部分执行与硬件相关的处理要求快, 而有些驱动在中断处理程序中又需要完成大量工作,这构成矛盾,所以Linux有所谓的bottom half机制，中断处理程序中所有不要求立即完成的,在开中断的环境下,由底半程序随后完成.
Linux的底半处理实际上是建立在内核的软中断机制上的.
Linux 的底半 机制主要有Tasklet 和 work queue 以及 softirq ( 2.4内核则有BH , Task queue , softirq , tasklet 没有work queue)，其实底半可以理解成一种工作的延迟。所以实际使用时跟timer机制基本上一个意思。

中断是一个处理器的稀缺资源，在系统中非常重要，通过中断能够及时高效的响应外部
事件，提高系统的响应能力，增加系统吞吐量。

为了避免中断处理函数长时间占用CPU资源，影响系统的并发和响应能力；
为了CPU资源在各个任务之间都能得到一个很多资源的使用和切换；
Linux内核提出顶半部和底半部机制：
顶半部：
1.本质还是中断处理函数
2.执行原先中断处理函数中紧急，耗时较短的任务
3.不可被中断
4.登记底半部的内容，以便将来CPU去执行

底半部：
1.本质是延后执行的一种手段
2.
3.可以被别的任务中断
4.登记后，就获取CPU资源，底半部的内容就立马得到执行
实现方法：tasklet、工作队列、软中断

竞态：内存资源，共享资源的访问
中断屏蔽
自旋锁
信号量
原子操作

等待队列机制：CPU资源调度利用
实现进程在内核空间随时随地休眠，随时被唤醒


内存管理：

//==============================================20181205===========
C/C++ Linux系统编程笔试题目 - 舞动的心 - CSDN博客
https://blog.csdn.net/zjq_5586288/article/details/81320528

网络编程面试题 - 蚂蚁吃大象、 - 博客园
https://www.cnblogs.com/jeakeven/p/5311575.html


1、connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？
答:最通常的方法最有效的是加定时器；也可以采用非阻塞模式。

2、网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？
答:若客户端掉线或者重新启动，服务器端会收到复位信号，每一种tcp/ip得实现不一样，控制机制也不一样。

3.在子网210.27.48.21/30种有多少个可用地址？分别是什么？
答:

简:
30表示的是网络号(network number)是30位，剩下2位中11是广播(broadcast)地址，00是multicast地址，只有01和10可以作为host address。

详:
210.27.48.21/30代表的子网的网络号是30位，即网络号是210.27.48.21 & 255.255.255.251=210.27.48.20，此子网的地址空间是2位，即可以有4个地址：210.27.48.20, 210.27.48.21, 210.27.48.22, 210.27.48.23。第一个地址的主机号(host number/id)是0，而主机号0代表的是multicast地址。最后一个地址的最后两位是11，主机号每一位都为1代表的是广播(broadcast)地址。所以只有中间两个地址可以给host使用。其实那个问题本身不准确，广播或multicast地止也是可以使用的地址，所以回答4也应该正确，当然问的人也可能是想要你回答2。我个人觉得最好的回答是一个广播地址，一个multicast地址，2个unicast地址。

4.TTL是什么？有什么用处，通常那些工具会用到它？（ping? traceroute? ifconfig? netstat?）
答:
简:TTL是Time To Live，一般是hup count，每经过一个路由就会被减去一，如果它变成0，包会被丢掉。它的主要目的是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute用到它。

详:TTL是Time To Live，目前是hup count，当包每经过一个路由器它就会被减去一，如果它变成0，路由器就会把包丢掉。IP网络往往带有环(loop)，比如子网A和子网B有两个路由器相连，它就是一个loop。TTL的主要目的是防止包在有回路的网络上死转，因为包的TTL最终后变成0而使得此包从网上消失(此时往往路由器会送一个ICMP包回来，traceroute就是根据这个做的)。ping会送包出去，所以里面有它，但是ping不一定非要不可它。traceroute则是完全因为有它才能成的。ifconfig是用来配置网卡的，netstat -rn 是用来列路由表的，所以都用不着它

5.路由表示做什么用的？在linux环境中怎么来配置一条默认路由？
答:
简:路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。在Linux上可以用“route add default gw <默认路由器IP>”来配置一条默认路由。

详: 路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。路由表的每一行至少有目标网络号、netmask、到这个子网应该使用的网卡。当路由器从一个网卡接收到一个包时，它扫描路由表的每一行，用里面的netmask和包里的目标IP地址做并逻辑运算(&)找出目标网络号，如果此网络号和这一行里的网络号相同就将这条路由保留下来做为备用路由，如果已经有备用路由了就在这两条路由里将网络号最长的留下来，另一条丢掉，如此接着扫描下一行直到结束。如果扫描结束任没有找到任何路由，就用默认路由。确定路由后，直接将包送到对应的网卡上去。在具体的实现中，路由表可能包含更多的信息为选路由算法的细节所用。题外话：路由算法其实效率很差，而且不scalable，解决办法是使用IP交换机，比如MPLS。
在Linux上可以用“route add default gw <默认路由器IP>”来配置一条默认路由。

6.在网络中有两台主机A和B，并通过路由器和其他交换设备连接起来，已经确认物理连接正确无误，怎么来测试这两台机器是否连通？如果不通，怎么来判断故障点？怎么排除故障？
答:测试这两台机器是否连通：从一台机器ping另一台机器
     如果ping不通，用traceroute可以确定是哪个路由器不能连通，然后再找问题是在交换设备/hup/cable等。

7.网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？ 
答案一:
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

答案二:
根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：
1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。
2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。
3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。
等等

//=========================================================
什么是死锁：
死锁是指两个或两个以上的执行序列在执行过程中，因为争夺资源而造成的一种相互等待
的现象。
例如：一个线程T1已锁定了一个资源R1,有想去锁定资源R2,而此时另一个线程T2已经锁定
了资源R2,却又想去锁定资源R1.这两个线程都想得到对方的资源，而又不愿释放自己的资源
，结果就是两个线程都在等待而无法执行。

死锁的避免：
	确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。
	可规定程序内有三个互斥锁的加锁顺序为 mutexA->mutexB->mutexC。
	
	
避免死锁的几种方式 - In_new的文章 - CSDN博客
https://blog.csdn.net/qq_38663729/article/details/80058980

避免死锁的几种方式：
设置加锁顺序
设置加锁时限
死锁检测


进程死锁 - zkc_home - CSDN博客
https://blog.csdn.net/weixin_40423553/article/details/78879122

死锁的四个必要条件（重点，务必记住）
互斥条件：涉及的资源是非共享的
不剥夺条件：不能强行剥夺进程拥有的资源
部分分配条件：进程在等待新资源时，依然占者已有资源
环路条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求。
//-------------------------------------------------------------
一语句实现x是否为2的若干次幂的判断。
  【参考答案】 
void main(){                                                                                      	
	int a;    
	scanf(“%d”,&a);
	printf(“%c”,(a)&(a-1)?’n’:’y’); //  若是打印y，否则n 
}