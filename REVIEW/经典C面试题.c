下面的代码：
int square(volatile int *ptr)
{
	int a,b;
	a = *ptr;
	b = *ptr;
	return a * b;
}
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr)
{
	int a;
	a = *ptr;
	return a * a;
}

/*----------------------------------------------------------------------15道经典面试题--------------------------------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------1-------------------------------------------------------------------------------------------------------*/　
 　  char * const p;
　　char const * p
　　const char *p
　　上述三个有什么区别？
　　char * const p; //常量指针，p的值不可以修改
　　char const * p；//指向常量的指针，指向的常量值不可以改
　　const char *p； //和char const *p
/*-----------------------------------------------------------------------------------------2-------------------------------------------------------------------------------------------------------*/　
　	char str1[] = "abc";
　  char str2[] = "abc";
　　const char str3[] = "abc";
　　const char str4[] = "abc";
　　const char *str5 = "abc";
　　const char *str6 = "abc";
　　char *str7 = "abc";
　　char *str8 = "abc";
　　cout << ( str1 == str2 ) << endl;
　　cout << ( str3 == str4 ) << endl;
　　cout << ( str5 == str6 ) << endl;
　　cout << ( str7 == str8 ) << endl;
   打印结果是什么？

解答：结果是：0 0 1 1
str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域

/*-----------------------------------------------------------------------------------------3-------------------------------------------------------------------------------------------------------*/　
以下代码中的两个sizeof用法有问题吗？
　　void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
　　{
    　　for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i )
        　if( 'a'<=str[i] && str[i]<='z' )
           str[i] -= ('a'-'A' );
　　}
　　char str[] = "aBcDe";
　　cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;
　　UpperCase( str );
　　cout << str << endl;
答：函数内的sizeof有问题。
根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。
函数外的str是一个静态定义的数组，因此其大小为6，
函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。

/*-----------------------------------------------------------------------------------------4------------------------------------------------------------------------------------------------------*/　
	main()
　　{
　　　int a[5]={1,2,3,4,5};
　　　int *ptr=(int *)(&a+1);
　　　printf("%d,%d",*(a+1),*(ptr-1));
　　}
   输出结果是什么？

　　答案：输出：2,5
　　*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5
　　&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）
　　int *ptr=(int *)(&a+1);
　　则ptr实际是&(a[5]),也就是a+5
　　
　　原因如下：
　　&a是数组指针，其类型为 int (*)[5];
　　而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。
　　a是长度为5的int数组指针，所以要加 5*sizeof(int)
　　所以ptr实际是a[5]
　　但是prt与(&a+1)类型是不一样的(这点很重要)
　　所以prt-1只会减去sizeof(int*)
　　a,&a的地址是一样的，但意思不一样
    a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，
    a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].

/*-----------------------------------------------------------------------------------------5-------------------------------------------------------------------------------------------------------*/　
请问以下代码有什么问题：
　　int  main()
　　{
		char a;
		char *str=&a;
		strcpy(str,"hello");
		printf(str);
		return 0;
　　}
　　答案：没有为str分配内存空间，将会发生异常。问题出在将一个字符串复制进一个字符变量指针所指地址。
虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。

/*-----------------------------------------------------------------------------------------6-------------------------------------------------------------------------------------------------------*/　  
char* s="AAA";
printf("%s",s);
s[0]='B';
printf("%s",s);

　　有什么错？///字符常量，不能改变其内容
　　答案：
"AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。
cosnt char* s="AAA";
然后又因为是常量，所以对是s[0]的赋值操作是不合法的。


/*-----------------------------------------------------------------------------------------7-------------------------------------------------------------------------------------------------------*/　
7. int (*s[10])(int) 表示的是什么？
　　答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

/*-----------------------------------------------------------------------------------------8-------------------------------------------------------------------------------------------------------*/　
	　有以下表达式：
　　int a=248; b=4;
　　int const c=21;
　　const int *d=&a;
　　int *const e=&b;
　　int const *f const =&a;
　　请问下列表达式哪些会被编译器禁止？为什么？
　　*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;

　　答案：
   *c 这是个什么东东，禁止
　　*d 说了是const， 禁止
　　e = &a 说了是const 禁止
　　const *f const =&a; 禁止

/*-----------------------------------------------------------------------------------------9-------------------------------------------------------------------------------------------------------*/　
	#include <stdio.h>
　  #include <stdlib.h>
　　void getmemory(char *p)
　　{　
　　　p=(char *) malloc(100);
　　　strcpy(p,"hello world");
　　}　
　　int main( )
　　{
　　　char *str=NULL;
　　　getmemory(str);
　　　printf("%s/n",str);
　　　free(str);
　　　return 0;
　　}
   分析一下这段代码
　　答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险
　　博主：getmemory中p是形参，是一个指针变量，getmemory(str)调用后，传入的是指针变量保存的对象地址，p=(char *) malloc(100)
实际上是把申请的动态内存空间的首地址付给p指向的地址（即str指向的地址null），这个是错误的。
应该修改成指向指针的指针void getmemory(char **p)，这样malloc返回的地址付给*p（即str变量本身）。
//------------------------------------------------------------------------------------
void get_str(char *p)
{
   p =(char*)malloc(strlen("abcd") + 1);
   strcpy(p,"abcd");
}

main()
{
   char *p= NULL;
   get_str(p);
   printf("%s",p);
}
输出NULL   因为一级指针当形参，不能改变其指向，只能改变其指向位置的内容；改变指向的话用二级指针。
//------------------------------------------------------------------------------------
char *get_str()

{
   char *p= "Hello World";
   return p;
}

main()
{
 	printf("%s",get_str());
}
输出Hello World
//------------------------------------------------------------------------------------
char *get_str()
{
   char p[] = "Hello World";
   return p;
}
main()
{
 	printf("%s",get_str());
}
输出结果不确定 get_str 返回的是局部变量指针，而局部变量在函数执行完后自动释放，所以输出的结果不确定

char *get_str()
{
   char p[] = "Hello World";
   return p;
}
main()
{
	char *str= NULL;
   str=get_str();
	strcpy(p,"abcd");
   printf("%s",p);//输出结果不确定
}
printf("%s\n",p);//程序崩溃
/*-----------------------------------------------------------------------------------------10-------------------------------------------------------------------------------------------------------*/　
	char szstr[10];
  　strcpy(szstr,"0123456789");
  　　产生什么结果？为什么？
　　答案：长度不一样，会造成非法的OS

/*-----------------------------------------------------------------------------------------11-------------------------------------------------------------------------------------------------------*/　
要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;
那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
　　答案：*((void (*)( ))0x100000 ) ( );
　　首先要将0x100000强制转换成函数指针,即:
　　(void (*)())0x100000
　　然后再调用它:
　　*((void (*)())0x100000)();
　　用typedef可以看得更直观些:
　　typedef void(*)() voidFuncPtr;
　　*((voidFuncPtr)0x100000)();

/*-----------------------------------------------------------------------------------------12-------------------------------------------------------------------------------------------------------*/　
分析下面的程序：
　　void GetMemory(char **p,int num)
　　{                          
		//p，指向指针的指针，*p，p指向的指针(即str)，**p，最终的对象，str指向的单元
　　　*p=(char *)malloc(num);  //申请空间首地址付给传入的被p指向的指针，即str
　　}   
   
　　int main()
　　{
		char *str=NULL;
　　　GetMemory(&str,100);   //传入指针变量本身的地址
　　　strcpy(str,"hello");
　　　free(str);
　　　if(str!=NULL)
　　　{
  　　　　strcpy(str,"world");
　　　}   
　　　printf("/n str is %s",str);// 软件开发网 www.mscto.com
　　　getchar();
　　} 
　　问输出结果是什么？
　　答案：输出str is world。
　　free 只是释放的str指向的内存空间,它本身的值还是存在的.所以free之后，有一个好的习惯就是将str=NULL.
此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,
尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。
这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。
　　当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的。
/*-----------------------------------------------------------------------------------------13-------------------------------------------------------------------------------------------------------*/　
	char a[10]；
	strlen(a)为什么等于15？
　　#include "stdio.h"
　　#include "string.h"
　　void main()
　　{
　　　char aa[10];
　　　printf("%d",strlen(aa));
　　}
　　答案：sizeof()和初不初始化，没有关系；strlen()和初始化有关。


/*-----------------------------------------------------------------------------------------14-------------------------------------------------------------------------------------------------------*/　
char (*str)[20];/*str是一个数组指针，即指向数组的指针．*/
char *str[20];/*str是一个指针数组，其元素为指针型数据．*/



/*-------------------------- --------------------------------------------有关内存的思考题 -----------------------------------------------------------------------------------------------*/
四、有关内存的思考题（每小题5分，共20分）
void GetMemory(char *p)
{
	p = (char *)malloc(100);
}
void Test(void) 
{
	char *str = NULL;
	GetMemory(str); 
	strcpy(str, "hello world");
	printf(str);
}
请问运行Test函数会有什么样的结果？
答：试题传入GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完
char *str = NULL; 
GetMemory( str ); 
后的str仍然为NULL；
 //--------------------------------------------------------------------------------------------------------------
//201812
char *GetMemory(void)
{ 
	char p[] = "hello world";
	return p;
}
void Test(void)
{
	char *str = NULL;
	str = GetMemory(); 
	printf(str);
}
请问运行Test函数会有什么样的结果？
答：可能是乱码。            
char p[] = "hello world";       
return p;  
函数的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。
 
//--------------------------------------------------------------------------------------------------------
//201812
void GetMemory2(char **p, int num)
{
	*p = (char *)malloc(num);
}
void Test(void)
{
	char *str = NULL;
	GetMemory(&str, 100);
	strcpy(str, "hello"); 
	printf(str); 
}
请问运行Test函数会有什么样的结果？
答：
（1）能够输出hello
（2 ）Test函数中也未对malloc的内存进行释放。
（3）GetMemory避免了试题1的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句
*p = (char *) malloc( num ); 
后未判断内存是否申请成功，应加上：
if ( *p == NULL ) 
 { 
   ...//进行申请内存失败处理 
　}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//201812
void Test(void)
{
char *str = (char *) malloc(100);
 strcpy(str, “hello”);
 free(str);     
	 if(str != NULL) 
	 {
		strcpy(str, “world”); 
		printf(str);
	}
}
请问运行Test函数会有什么样的结果？
答：执行可以输出world，但
char *str = (char *) malloc(100); 
后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：
str = NULL;

//20181201
//一个递规反向输出字符串的例子,可谓是反序的经典例程.
void inverse(char *p)
{
     if( *p = = '/0' ) {
		return;
	}
     inverse( p+1 );
     printf( "%c", *p );
}
int main(int argc, char *argv[])
{
     inverse("abc/0");
     return 0;
}

//===================================================================================================================
/*
	2）输出和为一个给定整数的所有组合
	例如n=5
	5=1+4；5=2+3（相加的数不能重复）
	则输出
	5 = 1+4
	5 = 2+3
	这里注意，不能考虑负数，否则将有无数种情况。
*/

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
	unsigned long int num, mid;
	unsigned long int i;
	
	printf("请输入一个任意整数：");
	scanf("%ld", &num);
	
	/*这个if和else是核心，避免了如2+3和3+2的情况*/
	if (num % 2 == 0)
		mid = num / 2;
	else
		mid = num / 2 + 1;
	
	printf("结果：\n");
	for (i=0; i<mid; i++)
		printf("%ld = %ld+%ld\n", num, i, num-i);
		
	return 0;
}

//========================================================
//快速统计给定整数二进制形式中1的个数.
      int func( int x）
      {
           int count = 0;
           while (x)
           {
              count ++;
               x = x & (x-1);
           }
          return count;
      }
/*
      如输入9999，该函数返回8。
     注：9999 = 9 x1024 +512 +256 +15
*/
//========================================================
//写一个程序，以递归方式反序输出一个字符串。如给定字符串“abc"输出“cba ”。
#include<stdio.h>
void reverse(char *p)
{
	if( *p == '\0')
		return;
	reverse(p+1);
	printf(“%c",*p);
   }
int main()
{
        reverse("abc");
        printf("\n");
         return 0;
}
//========================================================
