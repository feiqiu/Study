2017-10-29
gcc 编译选项-fPIC/-fpic:
-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position Independent Code，则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意
位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。

gcc 生成动态库时-fpic选项是什么意思 - CSDN博客
http://blog.csdn.net/wishfly/article/details/45694231

大模式和小模式的区别在哪里:-fPIC和-fpic的区别? - C/C++-ChinaUnix.net
http://bbs.chinaunix.net/thread-4063737-1-1.html

//------------------------------20171215----------------------------------
select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作
poll函数:
头文件：
	#include<poll.h>
函数体：
	int poll(struct pollfd *fds, nfds_t nfds, int timeout);
功能：
	监视并等待多个文件描述符的属性变化
	
参数：
	fds:指向一个结构体数组的第0个元素的指针，每个数组元素都是一个struct pollfd结
	构，用于指定测试某个给定的fd的条件
	
		struct pollfd{  
		    int fd;         //文件描述符  
		    short events;   //等待的事件  
		    short revents;  //实际发生的事件  
		};  

		fd：每一个 pollfd 结构体指定了一个被监视的文件描述符，可以传递多个结构
		体，指示 poll() 监视多个文件描述符。
		events：指定监测fd的事件（输入、输出、错误），每一个事件有多个取值，
		POLLIN：读事件
		POLLOUT：写事件
		POLLERR：错误事件

		revents：
	     revents域是文件描述符的操作结果事件，内核在调用返回时设置这个域。
		events 域中请求的任何事件都可能在 revents 域中返回.
		
	注意：每个结构体的events域是由用户来设置，告诉内核我们关注的是什么，而 revents 域是返回时内核设置的，以说明对该描述符发生了什么事件。

	nfds:用来指定第一个参数数组元素个数
		
	timeout: 指定等待的毫秒数，无论 I/O 是否准备好，poll() 都会返回.
		-1：永远等待，直到事件发生
		0：立即返回
		>0:等待指定数目的毫秒数

返回值：
成功时，poll() 返回结构体中 revents 域不为 0 的文件描述符个数；如果在超时前没有任何事件发生，poll()返回 0；失败时，poll() 返回 -1。	
	
Linux网络编程――I/O复用之poll函数 - CSDN博客
http://blog.csdn.net/lianghe_work/article/details/46534029

//---------------------------------------

Linux inotify功能及实现原理 - CSDN博客
http://blog.csdn.net/myarrow/article/details/7096460


inotify_init
inotify_add_watch
inotify_event
input_manager_t

 
 
//-----------------------------20171219-----------------------
uinput:?用户空间虚拟输入事件_AirAir_新浪博客
http://blog.sina.com.cn/s/blog_64fb9b920102v8ab.html

使用/dev/uinput的简要介绍（含demo程序） - ZHONGkunjia的专栏 - CSDN博客
http://m.blog.csdn.net/zhongkunjia/article/details/75142699

Linux /dev/uinput - CSDN博客
http://blog.csdn.net/myarrow/article/details/12105973

查看/dev/input/eventX是什么类型的事件， cat /proc/bus/input/devices

//----------------------------20190405-------------------------------------------------------
linux中多线程操作，互斥锁，条件锁 - wangqing_12345的博客 - CSDN博客 - https://blog.csdn.net/wangqing_12345/article/details/68490842

Linux多线程之互斥锁 - MakerCloud的博客 - CSDN博客 - https://blog.csdn.net/makercloud/article/details/80230559

Linux多线程的使用一：互斥锁 - Leon08 - 博客园 - https://www.cnblogs.com/leon08/p/4084077.html

pthread_mutex_trylock - xiaohendsc的专栏 - CSDN博客 - https://blog.csdn.net/xiaohendsc/article/details/9305785

//------------20200301--------------------------------------------
lseek()
//-------------20200312-------------------------------------------------
什么是线程死锁?如何解决?（蚂蚁金服面试题） - 一说烟雨 - 博客园 - https://www.cnblogs.com/ysyy/p/10904081.html
多线程死锁的产生以及如何避免死锁 - sthu - 博客园 - https://www.cnblogs.com/sthu/p/9660914.html

//-------------20200312-------------------------------------------------
BSS是英文Block?Started?by?Symbol的简称
总结：
   (1)按照地址从小到大进行排列,进程中的内存区域依次为：代码区、只读常量区、全局区/数据区、BSS段、 堆区、栈区
   (2)其中代码区和只读常量区一般统称为代码区；其中全局区/数据区和BSS段一般统称为全局区/数据区
   (3)栈区和堆区之间并没有严格的分割线，可以进行微调，并且堆区的分配一般按照地址从小到大进行，而栈区的分配一般按照地址从大到小进行分配

1.2 字符串的存储形式之间的比较
   对于指向常量字符串的字符指针和字符数组来说，字符指针可以改变指向，不可以改变指向的内容;对于字符数组来说，可以改变指向的内容，不可以改变指向
   对于存放常量字符串的堆区来说,指针的指向和指针指向的内容都可以改变
---------------------------------------------------------------------------
3.内存管理
3.1 程序和进程的概念
   程序 - 主要指在硬盘上的可执行文件
   进程 - 主要指在内存中运行的程序
3.2 进程中的内存区域划分
如：
   int num; => 全局变量 初始值0  BSS段
   int main(void)
   {
       int num; => 局部变量 初始值是随机数 栈区
       return 0;
   }
(1)代码区 
   - 存储功能代码,函数名所在的区域
(2)只读常量区
   - 存放字符串常量,以及const修饰的全局变量
(3)全局区/数据区
   - 存放已经初始化的全局变量和static修饰的局部变量
(4)BSS段
   - 存放没有初始化的全局变量和静态局部变量，该区域会在main函数执行之前进行自动清零
(5)堆区
   - 使用malloc/calloc/realloc/free函数处理的内存,该区域的内存需要程序员手动申请和手动释放
(6)栈区
   - 存放局部变量(包括函数的形参)、const修饰的局部变量，以及块变量，该区域的内存由操作系统负责分配和回收，程序员尽管放心使用即可
---------------------------------------------------------------------------
进程在系统内存的分配：
进程在内存空间中的布局形成进程映像，从低地址到高地址依次为

代码区(text)：其中存放的是可执行指令、字面值常量、具有常属性且被初始化的全局变量和静态局部变量。

数据区(data)：其中存放的是不具有常属性且被初始化的全局变量和静态局部变量。

BSS区(bss)：其中存放的是未被初始化的全局变量和静态局部变量。

堆区(heap)：其中存放的是动态分配内存。

栈区(stack)：其中存放的是非静态局部变量。

参数和环境区：其中存放的是命令行参数和环境变量。
--------------------------------------------------------------------------------

   
 

